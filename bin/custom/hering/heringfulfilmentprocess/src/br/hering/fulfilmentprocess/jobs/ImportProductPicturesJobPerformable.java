package br.hering.fulfilmentprocess.jobs;

import java.io.File;
import java.io.FilenameFilter;
import java.security.InvalidParameterException;
import java.util.Date;

import org.apache.commons.io.FileUtils;
import org.apache.commons.lang.ArrayUtils;
import org.apache.commons.lang.StringUtils;
import org.apache.log4j.Logger;
import org.springframework.util.Assert;

import br.hering.fulfilmentprocess.model.jobs.ImportProductPicturesJobModel;
import de.hybris.platform.cronjob.enums.CronJobResult;
import de.hybris.platform.cronjob.enums.CronJobStatus;
import de.hybris.platform.europe1.constants.Europe1Constants.ImpEx;
import de.hybris.platform.impex.jalo.ImpExException;
import de.hybris.platform.impex.jalo.Importer;
import de.hybris.platform.impex.jalo.imp.DumpHandler;
import de.hybris.platform.servicelayer.cronjob.AbstractJobPerformable;
import de.hybris.platform.servicelayer.cronjob.PerformResult;
import de.hybris.platform.util.CSVReader;

public class ImportProductPicturesJobPerformable extends
		AbstractJobPerformable<ImportProductPicturesJobModel> {
	private Logger LOG = Logger
			.getLogger(ImportProductPicturesJobPerformable.class);

	/**
	 * Defines the absolute path of the directory that contains all the
	 * {@link ImpEx} files used to import product pictures
	 */
	public static final String IMPORT_PRODUCT_PICTURES_SCRIPT_DIR = "/HYBRIS/medias/impex";
	// public static final String IMPORT_PRODUCT_PICTURES_SCRIPT_DIR =
	// "C:\\hering\\hybris\\bin\\platform\\tomcat\\work\\Catalina\\localhost\\hybris\\medias\\impex";

	/**
	 * Defines the name prefix of the files that shall be considered a product
	 * picture {@link ImpEx}
	 */
	public static final String IMPORT_PRODUCT_PICTURES_SCRIPT_PREFIX = "imp_prod_imgs_";

	/**
	 * Define the URL used to download the current CSV
	 */
	public static final String IMPORT_PRODUCT_PICTURES_SCRIPT_DOWNLOAD_URL = "/medias/sys_master/media/impex/";

	/**
	 * Defines the URL used to download the dump files generated by wrong
	 * importing process.
	 */
	public static final String IMPORT_PRODUCT_PICTURES_SCRIPT_DUMP_DOWNLOAD_URL = IMPORT_PRODUCT_PICTURES_SCRIPT_DOWNLOAD_URL
			+ "status/";

	/**
	 * Defines the suffix for dump file names
	 */
	public static final String IMPORT_PRODUCT_PICTURES_SCRIPT_DUMP_SUFFIX = "_status.csv";

	/**
	 * Defines the absolute path of the directory that contains all the dump
	 * files.
	 */
	public static final String IMPORT_PRODUCT_PICTURES_SCRIPT_DUMP_DIR = IMPORT_PRODUCT_PICTURES_SCRIPT_DIR
			+ "/status/";

	@Override
	public PerformResult perform(ImportProductPicturesJobModel job) {
		Assert.notNull(job);
		LOG.info("Job started");
		final String[] importScripts = listImportProductPicturesScripts();

		if (!ArrayUtils.isEmpty(importScripts)) {
			for (final String scriptName : importScripts) {
				try {
					importProductPictureScript(scriptName);
					deleteScriptAndRelatedDumpFile(scriptName);
				} catch (Exception e) {

					LOG.error("Error importing script: " + scriptName, e);
					// notifyError(e.getMessage(), (e instanceof
					// ImpExException));
					/*return new PerformResult(CronJobResult.ERROR,
							CronJobStatus.FINISHED);*/
				}
			}
		} else {
			LOG.info("Nothing to import.");
			return new PerformResult(CronJobResult.ERROR,
					CronJobStatus.FINISHED);
		}
		return new PerformResult(CronJobResult.SUCCESS, CronJobStatus.FINISHED);
	}

	/**
	 * This method is responsible for importing the content of the script passed
	 * as parameter.<br />
	 * It uses the HYBRIS {@link Importer} API to execute the {@link ImpEx}
	 * importer against the given script. <br />
	 * HYBRIS API documentation:
	 * https://wiki.hybris.com/display/release4/ImpEx+API
	 * 
	 * @param scriptName
	 *            The name of the script that has to be imported, this name
	 *            shall not contain the absolute file path. <br />
	 * @throws Exception
	 *             If an error happens while executing the import process
	 */
	private void importProductPictureScript(final String scriptName)
			throws Exception {

		if (StringUtils.isBlank(scriptName)) {
			throw new InvalidParameterException("scriptName is empty!");
		}

		final File importScript = new File(IMPORT_PRODUCT_PICTURES_SCRIPT_DIR,
				scriptName);
		if (!importScript.exists()) {
			throw new InvalidParameterException(scriptName
					+ " does not exists!");
		}

		LOG.info("Importing script " + scriptName);

		final CSVReader reader = new CSVReader(importScript, "utf-8");
		final Importer importer = new Importer(reader);

		try {
			importer.importAll();
			createDumpFileDownloadable(scriptName);
		} catch (Exception e) {

			StringBuilder msg = new StringBuilder();
			msg.append("Errors importing ").append(scriptName)
					.append(", consult Support team for further details.");

			if (StringUtils.isNotBlank(e.getMessage())) {
				msg.append("\nError message: " + e.getMessage());
			}

			msg.append("\nDownload the CSV file: ")
					// .append(getHost())
					.append(IMPORT_PRODUCT_PICTURES_SCRIPT_DOWNLOAD_URL)
					.append(scriptName);

			String dumpFileName = makeDumpFileDownloadable(scriptName,
					importer.getDumpHandler());
			if (StringUtils.isNotBlank(dumpFileName)) {
				msg.append("\nDownload the Impex dump file: ")
						// .append(getHost())
						.append(IMPORT_PRODUCT_PICTURES_SCRIPT_DUMP_DOWNLOAD_URL)
						.append(dumpFileName);
			}

			throw new ImpExException(msg.toString());
		}

		LOG.info("Import Successfull " + scriptName + " " + new Date().toString());
	}

	/**
	 * This method will list all the available scripts that are contained into
	 * the path specified by the constant IMPORT_PRODUCT_PICTURES_SCRIPT_DIR.<br />
	 * A file is considered a script if it's name starts with the prefix
	 * specified by the constant IMPORT_PRODUCT_PICTURES_SCRIPT_PREFIX and if
	 * it's extension is CSV
	 * 
	 * @return
	 */
	private String[] listImportProductPicturesScripts() {

		// TODO TESTE

		final FilenameFilter fileFilter = new FilenameFilter() {
			@Override
			public boolean accept(File file, String name) {
				// we must use only the files which the name starts with the
				// given prefix and if it's a CSV file
				return (name.startsWith(IMPORT_PRODUCT_PICTURES_SCRIPT_PREFIX) && name
						.endsWith(".csv"));
			}
		};

		final File dir = new File(IMPORT_PRODUCT_PICTURES_SCRIPT_DIR);

		return dir.list(fileFilter);
	}

	/**
	 * Deletes the script that the name has been passed as parameter, also
	 * deletes related dump files.
	 * 
	 * @param fileToDelete
	 *            The name of the script to be deleted
	 * @return Boolean.<code>true</code> if the file has been deleted.<br />
	 *         Boolean.<code>false</code> if the file does not exists, if it is
	 *         a directory, or if the Java API couldn't delete the file because
	 *         of some SO permission for example.
	 */
	private boolean deleteScriptAndRelatedDumpFile(String fileToDelete) {

		if (StringUtils.isBlank(fileToDelete)) {
			return true;
		}

		final File file = new File(IMPORT_PRODUCT_PICTURES_SCRIPT_DIR,
				fileToDelete);
		if (!file.exists() || file.isDirectory()) {
			return false;
		}

		return file.delete();
	}

	/**
	 * This method will get the original dump file from the given
	 * {@link DumpHandler} and copy it to a new file to the directory which the
	 * used is able to access via browser and download the dump file.
	 * 
	 * @param scriptName
	 *            The original script name, which caused an error on the
	 *            importing process
	 * @param dumpHandler
	 *            The {@link DumpHandler} used to handle errors on the
	 *            {@link Importer} instance.
	 * @return The generated dump file name.
	 */
	private String makeDumpFileDownloadable(final String scriptName,
			final DumpHandler dumpHandler) {

		if (StringUtils.isBlank(scriptName) || dumpHandler == null) {
			return null;
		}

		File dumpAsFile = dumpHandler.getDumpAsFile();
		if (dumpAsFile != null) {
			try {
				File downloadableDump = new File(
						buildDownloadableDumpFileName(scriptName));
				FileUtils.copyFile(dumpAsFile, downloadableDump);
				return downloadableDump.getName();
			} catch (Exception err) {
				LOG.error(
						"Error copying the dump file for "
								+ dumpAsFile.getAbsolutePath(), err);
			}
		}

		return null;
	}

	/**
	 * This method will create a new file on directory which the used is able to
	 * access via browser and download the dump file.
	 * 
	 * @param scriptName
	 *            The original script name, which caused an error on the
	 *            importing process
	 * @return The generated dump file name.
	 */
	private void createDumpFileDownloadable(final String scriptName) {
		try {
			File downloadableDump = new File(
					buildDownloadableDumpFileName(scriptName));

			if (downloadableDump.exists()) {
				FileUtils.deleteQuietly(downloadableDump);
			} else {
				downloadableDump.createNewFile();
			}

			FileUtils.writeStringToFile(downloadableDump,
					"#No errors on product pictures import.");
		} catch (Exception err) {
			LOG.error("Error to create import dump file", err);
		}
	}

	/**
	 * Builds the name of a downloadable dump file using the original script
	 * name and appending the dump file suffix defined by the constant named
	 * IMPORT_PRODUCT_PICTURES_SCRIPT_DUMP_SUFFIX.
	 * 
	 * @param scriptName
	 *            The original script name.
	 * @return The dump file name.
	 */
	private String buildDownloadableDumpFileName(final String scriptName) {
		if (StringUtils.isBlank(scriptName)) {
			return "";
		}

		return (IMPORT_PRODUCT_PICTURES_SCRIPT_DUMP_DIR + scriptName)
				.replaceAll(".csv", IMPORT_PRODUCT_PICTURES_SCRIPT_DUMP_SUFFIX);
	}	
}